<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./css/style.css">
</head>
<body>
    <a href="#pinggy">Aller √† la section pinggy</a>
    <a href="#connexion4G">Aller √† la section connexion4G</a>
    <a href="#machineEtat">Aller √† la section machineEtat</a>
    <p>Build automatiquement en faisant upload - restart l'upload </p>
    <h4>Ne pas h√©siter √† spam le ctrl + alt + s, ca peut fonctionner au bout d'un moment</h4>
    <h4>OVERFLOW millis() </h4>

    <h5>Appuyer deux fois sur enable et l'autre boutons en m√™me temps. 
    <br>Ensuite relacher le bouton enable, ca va boot. <br>
    Puis appuyer une fois sur enable et on va pouvoir restart.</h5>

    <div class="container">
        <h1>l'OVERFLOW</h1> 
        <p>L'overflow (d√©passement) est un probl√®me classique en programmation bas niveau, 
        notamment en C et dans l‚ÄôIoT, o√π les ressources m√©moire sont limit√©es.
        <br> Cela se produit lorsqu'une valeur d√©passe la capacit√© de stockage d'un type de donn√©e.</p>
    </div>
        <br>
        <div class="container">
            <h2>description carte</h2>
            
            <img src="./images/carte.jpg">
            <img src="./images/esp-sim.png.jpg">
        </div>

        <div class="container">

        <br>
        <h2>Issue COM3 - PORT </h2>
        <img src="./images/issue-com3.jpg">
        <p>Quand vous avez l'erreur que vous voyez : "Serial port COM3
            
            A fatal error occurred: Could not open COM3, the port doesn't exist
            *** [upload] Error 2
            ======================"
            <br> il faut appuyer sur la prise (fluo en jaune), ensuite choisir le nouveau com (en vert : "com4").
            <br> Ensuite upload. 
        </p>
        </div>
        <br>
        <div class="container">
        <h2> NIVEAU DE BATTERIE </h2>
        <img src="./images/niveau_batterie.jpg">
        <p>La commande AT+CBC renvoie l‚Äô√©tat de la batterie sous cette forme :
            <br>
           "
            +CBC: batterie_status, niveau_batterie, voltage_mV
            OK"

            <br><br>
            batterie_status :
            <br>0 = Non branch√©
            <br>1 = Chargement
            <br>2 = Charg√©
            <br>niveau_batterie : Pourcentage de la batterie (0 √† 100)
            <br>voltage_mV : Tension de la batterie en millivolts (mV)</p>

        </div>

    <br>
    <br>
    <br>
    <h5>IMPORTANT : ne pas importer plusieurs fois le m√™me fichier hpp sous peine d'avoir des bug en cascade, par exemple appeler la m√™me variable deux fois </h5>
    <h5> Quand on a plus le coucou : on doit juste appuyer sur le bouton enable</h5>
    <br>
    <br>
    <br>
    <br>

    <div class="container">
    <h2>Modification du fichier platform.ini</h2>
    <p>build_flags =
      <br>  -I../lib
      <br>  -I../lib/gnss
      <br>  -I../lib/power
      <br>  -I../lib/timestamp
      <br>  -I../lib/serial
      <br>  -I../lib/argali
    </p>

    <br>
    <p> build_flags va servir √† ne pas remettre le chemin relatif de nos dossiers √† chaque fois </p>
    </div>
    <br>
    <div class="container">
        <h1>üîç Les Pointeurs en C</h1>
        
        <p>Oui, tu peux d√©finir plusieurs pointeurs qui pointent vers la m√™me variable. Cela signifie que si tu modifies la valeur via l‚Äôun des pointeurs, tous les autres la verront aussi !</p>
        
        <h2>üìå Exemple de code :</h2>
        <pre>
#include &lt;stdio.h&gt;

int main() {
    int nombre = 42;      // D√©clare une variable normale
    int *ptr1 = &nombre;  // Premier pointeur
    int *ptr2 = &nombre;  // Deuxi√®me pointeur

    printf("Avant modification : %d\n", nombre);
    
    *ptr1 = 99;  // Modification via ptr1

    printf("Apr√®s modification via ptr1 : %d\n", nombre);
    printf("Valeur via ptr2 : %d\n", *ptr2);  // ptr2 voit aussi la mise √† jour

    return 0;
}
        </pre>

        <div class="explanation">
            <h2>üßê Explication :</h2>
            <p>1Ô∏è‚É£ <strong>Cr√©ation de la variable :</strong> <code>int nombre = 42;</code></p>
            <p>2Ô∏è‚É£ <strong>D√©claration de deux pointeurs :</strong> <code>ptr1</code> et <code>ptr2</code> stockent l‚Äôadresse de <code>nombre</code>.</p>
            <p>3Ô∏è‚É£ <strong>Modification via <code>ptr1</code> :</strong> <code>*ptr1 = 99;</code> change directement la valeur de <code>nombre</code>.</p>
            <p>4Ô∏è‚É£ <strong>Affichage avec <code>ptr2</code> :</strong> Il affiche aussi <code>99</code>, car il pointe sur la m√™me adresse.</p>
        </div>

        <h2>üì§ Sortie du programme :</h2>
        <pre>
Avant modification : 42
Apr√®s modification via ptr1 : 99
Valeur via ptr2 : 99
        </pre>

        <p>‚úÖ Plusieurs pointeurs peuvent partager la m√™me adresse en m√©moire. Toute modification via l‚Äôun d‚Äôeux impacte directement la variable point√©e.</p>
    </div>

    <br>
    <br>
    <br>

    <div class="container">
        <h1>üìå Pourquoi utiliser des pointeurs en argument de fonction ?</h1>

        <p>En C, utiliser des pointeurs dans les fonctions offre plusieurs avantages, notamment :</p>

        <h2>‚úÖ 1Ô∏è‚É£ Modifier directement une variable</h2>
        <p>Sans pointeur, la fonction copie la variable, donc elle ne la modifie pas r√©ellement :</p>
        <pre>
int incrementer(int x) {
    x += 1;
    return x;
}</pre>
        <p>Avec un pointeur, la fonction modifie directement la variable en m√©moire :</p>
        <pre>
void incrementer(int *x) {
    *x += 1;
}</pre>

        <h2>‚úÖ 2Ô∏è‚É£ √âviter de copier une `struct` (Optimisation m√©moire)</h2>
        <p>Sans pointeur, la `struct` est copi√©e :</p>
        <pre>
void afficherPoint(Point p) {
    printf("Point (%d, %d)\n", p.x, p.y);
}</pre>
        <p>Avec un pointeur, on √©vite la copie (plus rapide) :</p>
        <pre>
void afficherPoint(Point *p) {
    printf("Point (%d, %d)\n", p->x, p->y);
}</pre>

        <h2>‚úÖ 3Ô∏è‚É£ Retourner plusieurs valeurs</h2>
        <p>Sans pointeur, une fonction ne peut retourner qu'une seule valeur :</p>
        <pre>
int somme(int a, int b) {
    return a + b;
}</pre>
        <p>Avec des pointeurs, on peut retourner plusieurs valeurs :</p>
        <pre>
void calculer(int a, int b, int *somme, int *difference) {
    *somme = a + b;
    *difference = a - b;
}</pre>

        <h2>‚úÖ 4Ô∏è‚É£ Retourner un tableau</h2>
        <p>En C, une fonction ne peut pas retourner un tableau directement :</p>
        <pre>
// Impossible :
int tableau[5];
return tableau;  // ERREUR</pre>
        <p>Mais avec un pointeur, c‚Äôest possible :</p>
        <pre>
int* creerTableau(int taille) {
    int *tab = (int*) malloc(taille * sizeof(int));
    return tab;
}</pre>

        <div class="explanation">
            <h2>üéØ Comparaison des m√©thodes</h2>
            <table>
                <tr>
                    <th>Cas d‚Äôusage</th>
                    <th>Sans pointeur</th>
                    <th>Avec pointeur</th>
                </tr>
                <tr>
                    <td>Modifier une variable</td>
                    <td>Copie, pas de modification directe</td>
                    <td>Modifie directement la valeur</td>
                </tr>
                <tr>
                    <td>Passer une `struct`</td>
                    <td>Copie compl√®te (lent)</td>
                    <td>Passe l'adresse (rapide)</td>
                </tr>
                <tr>
                    <td>Retourner plusieurs valeurs</td>
                    <td>Impossible</td>
                    <td>Possible avec plusieurs pointeurs</td>
                </tr>
                <tr>
                    <td>Retourner un tableau</td>
                    <td>Impossible</td>
                    <td>Possible avec un pointeur</td>
                </tr>
            </table>
        </div>

        <p>üí° En r√©sum√© :</p>
        <ul>
            <li>‚úÖ Si tu veux modifier une variable ‚Üí Utilise un pointeur</li>
            <li>‚úÖ Si tu veux √©viter de copier une `struct` ‚Üí Utilise un pointeur</li>
            <li>‚úÖ Si tu veux retourner plusieurs valeurs ‚Üí Utilise des pointeurs</li>
            <li>‚úÖ Si tu veux retourner un tableau ‚Üí Utilise un pointeur</li>
        </ul>

        <p><strong>Tu veux un exemple plus avanc√© avec gestion m√©moire et objets dynamiques ? üöÄüòä</strong></p>
    </div>

    <br>
    <br>
    <br>

    <div class="container">
        <h1>‚úÖ üìù Pointeurs et Fonctions Imbriqu√©es en C</h1>

        <h2>üìå Code C :</h2>
        <pre>
#include &lt;stdio.h&gt;

// Fonction secondaire qui modifie la variable
void ajouter10(int *ptr) {
    printf("[ajouter10] Adresse re√ßue : %p, Valeur avant : %d\n", ptr, *ptr);
    *ptr += 10;  // Ajoute 10 √† la valeur point√©e
    printf("[ajouter10] Valeur apr√®s : %d\n", *ptr);
}

// Fonction principale qui appelle une autre fonction
void function(int *ptr) {
    printf("[function] Adresse re√ßue : %p, Valeur actuelle : %d\n", ptr, *ptr);
    ajouter10(ptr);  // Appel √† une autre fonction en passant le pointeur
    printf("[function] Valeur apr√®s appel de ajouter10 : %d\n", *ptr);
}

int main() {
    int variable = 5;

    printf("[main] Avant function - Adresse de variable : %p\n", &variable);
    printf("[main] Avant function - Valeur de variable : %d\n", variable);

    function(&variable);  // On passe l'adresse de la variable

    printf("[main] Apr√®s function - Valeur de variable : %d\n", variable);

    return 0;
}
        </pre>

        <div class="explanation">
            <h2>üîç Explication :</h2>
            <p>1Ô∏è‚É£ `main()` cr√©e une variable `variable = 5`.</p>
            <p>2Ô∏è‚É£ Il passe l‚Äôadresse de `variable` √† `function(&variable)`.</p>
            <p>3Ô∏è‚É£ `function()` affiche l'adresse et la valeur, puis appelle `ajouter10(ptr)` en passant toujours le pointeur.</p>
            <p>4Ô∏è‚É£ `ajouter10()` ajoute `10` √† la valeur de `variable` via le pointeur.</p>
            <p>5Ô∏è‚É£ Retour dans `function()`, qui affiche la nouvelle valeur (`15`).</p>
            <p>6Ô∏è‚É£ Retour √† `main()`, la variable a bien √©t√© modifi√©e.</p>
        </div>

        <h2>üì§ Sortie du programme :</h2>
        <div class="output">
            [main] Avant function - Adresse de variable : 0x7ffee12a1b<br>
            [main] Avant function - Valeur de variable : 5<br>
            [function] Adresse re√ßue : 0x7ffee12a1b, Valeur actuelle : 5<br>
            [ajouter10] Adresse re√ßue : 0x7ffee12a1b, Valeur avant : 5<br>
            [ajouter10] Valeur apr√®s : 15<br>
            [function] Valeur apr√®s appel de ajouter10 : 15<br>
            [main] Apr√®s function - Valeur de variable : 15<br>
        </div>  
    </div>

    <br>
    <br>
    <br>

    <div class="container">
        <h1>‚úÖ Passer une `struct` dans une fonction en C</h1>

        <h2>‚úÖ 1Ô∏è‚É£ Passer une struct SANS pointeur (Copie de la struct)</h2>
        <pre>
#include &lt;stdio.h&gt;

// D√©finition d'une structure
typedef struct {
    char nom[50];
    int age;
} Personne;

// Fonction qui prend une struct par valeur (copie)
void afficherPersonne(Personne p) {
    printf("Nom : %s, √Çge : %d\n", p.nom, p.age);
}

int main() {
    // Cr√©ation d'une instance de struct
    Personne p1 = {"Alice", 25};

    // Passage de la structure √† la fonction
    afficherPersonne(p1);

    return 0;
}
        </pre>

        <h3>üì§ Sortie :</h3>
        <div class="output">
            Nom : Alice, √Çge : 25
        </div>

        <div class="explanation">
            <h2>‚ö†Ô∏è Attention :</h2>
            <ul>
                <li>‚úÖ Ici, la `struct` est **copi√©e** dans `afficherPersonne()`.</li>
                <li>‚ö†Ô∏è **Toute modification** dans `afficherPersonne()` **ne changera pas l'originale** `p1`.</li>
                <li>‚ö†Ô∏è Peu optimal pour des `struct` volumineuses, **car cela duplique les donn√©es**.</li>
            </ul>
        </div>

        <h2>‚úÖ 2Ô∏è‚É£ Passer une struct AVEC pointeur (`*struct`)</h2>
        <pre>
#include &lt;stdio.h&gt;

// D√©finition d'une structure
typedef struct {
    char nom[50];
    int age;
} Personne;

// Fonction qui prend un pointeur sur une struct (modification directe)
void modifierAge(Personne *p) {
    p->age += 1;  // Modification directe via le pointeur
}

int main() {
    // Cr√©ation d'une instance de struct
    Personne p1 = {"Bob", 30};

    printf("Avant : %s a %d ans\n", p1.nom, p1.age);

    // Passage par adresse
    modifierAge(&p1);

    printf("Apr√®s : %s a %d ans\n", p1.nom, p1.age);

    return 0;
}
        </pre>

        <h3>üì§ Sortie :</h3>
        <div class="output">
            Avant : Bob a 30 ans<br>
            Apr√®s : Bob a 31 ans
        </div>

        <div class="explanation">
            <h2>‚úÖ Avantages de l'utilisation d'un pointeur :</h2>
            <ul>
                <li>‚úÖ On passe **l'adresse** de `p1` avec `&p1`.</li>
                <li>‚úÖ **Modification directe** de la variable `p1` dans la m√©moire.</li>
                <li>‚úÖ **Pas de copie inutile**, id√©al pour des `struct` volumineuses.</li>
            </ul>
        </div>
    </div>
    <br>
    <br>
    <br>
    <br>

    <div class="container">
        <h1>‚úÖ Utilisation de `std::map` et `std::cout` en C++</h1>

        <h2>üìå Exemple d'utilisation de `std::map`</h2>
        <pre>
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

int main() {
    // D√©claration d'une map (cl√© = string, valeur = int)
    std::map&lt;std::string, int&gt; ages;

    // Ajout de valeurs
    ages["Alice"] = 25;
    ages["Bob"] = 30;
    ages["Charlie"] = 22;

    // Affichage avec std::cout
    for (const auto &pair : ages) {
        std::cout << pair.first << " a " << pair.second << " ans" << std::endl;
    }

    return 0;
}
        </pre>

        <h3>üì§ Sortie :</h3>
        <div class="output">
            Alice a 25 ans<br>
            Bob a 30 ans<br>
            Charlie a 22 ans
        </div>

        <div class="explanation">
            <h2>üîç Explication :</h2>
            <ul>
                <li>‚úÖ `std::map&lt;std::string, int&gt;` est une **map associant une cl√© (`string`) √† une valeur (`int`)**.</li>
                <li>‚úÖ `ages["Alice"] = 25;` **ajoute une cl√© "Alice" avec la valeur 25**.</li>
                <li>‚úÖ La boucle `for` parcourt tous les √©l√©ments de la map et affiche les cl√©s/valeurs.</li>
            </ul>
        </div>

        <h2>üìå Explication de `std::cout`</h2>
        <pre>
#include &lt;iostream&gt;

int main() {
    std::string nom = "Alice";
    int age = 25;

    // Affichage avec std::cout
    std::cout << "Nom : " << nom << ", √Çge : " << age << std::endl;

    return 0;
}
        </pre>

        <h3>üì§ Sortie :</h3>
        <div class="output">
            Nom : Alice, √Çge : 25
        </div>

        <div class="explanation">
            <h2>üîπ Comment fonctionne `std::cout` ?</h2>
            <ul>
                <li>‚úÖ `std::cout` signifie **"Character Output"**, il affiche des messages.</li>
                <li>‚úÖ `<<` est l'**op√©rateur de flux** qui concat√®ne les √©l√©ments.</li>
                <li>‚úÖ `std::endl` signifie **"End Line"**, il ajoute un retour √† la ligne (`\n`).</li>
            </ul>
        </div>
    </div>

    <br>
    <br>

    <div class="container" id="connexion4G">
        <h1>Connexion via 4G</h1>
        <img src="./images/connection4G.png">
        <img src="./images/terminalconnection4G.png">
        <h1>üì° Connexion LTE-M avec SIM7080G</h1>
        <p>Voici comment configurer le module SIM7080G pour se connecter au r√©seau LTE-M.</p>
        
        <h2>üîç 1Ô∏è‚É£ S√©lectionner LTE-M uniquement</h2>
        <div class="step">
            <p>On force le module √† utiliser LTE-M uniquement :</p>
            <div class="code">AT+CNMP=38</div>
        </div>

        <h2>üöÄ 2Ô∏è‚É£ Activer LTE-M et d√©sactiver NB-IoT</h2>
        <div class="step">
            <p>NB-IoT n'est pas support√© sur cette puce :</p>
            <div class="code">AT+CMNB=1</div>
        </div>

        <h2>üåç 3Ô∏è‚É£ Configurer l'APN</h2>
        <div class="step">
            <p>On d√©finit l'APN de l'op√©rateur pour la connexion Internet :</p>
            <div class="code">AT+CGDCONT=1,"IP","iot.1nce.net"</div>
        </div>

        <h2>üì∂ 4Ô∏è‚É£ V√©rifier l'enregistrement sur le r√©seau</h2>
        <div class="step">
            <p>On v√©rifie si le module est bien connect√© au r√©seau LTE-M :</p>
            <div class="code">AT+CEREG?</div>
        </div>

        <h2>üåê 5Ô∏è‚É£ Activer la connexion Internet</h2>
        <div class="step">
            <p>On active la connexion Internet (PDP context) :</p>
            <div class="code">AT+CNACT=0,1</div>
        </div>

        <h2>üì° 6Ô∏è‚É£ V√©rifier la connexion LTE-M</h2>
        <div class="step">
            <p>On s'assure que la connexion est bien active :</p>
            <div class="code">AT+CGATT?</div>
        </div>

        <h2>üìä 7Ô∏è‚É£ V√©rifier la qualit√© du signal</h2>
        <div class="step">
            <p>On teste la puissance du signal :</p>
            <div class="code">AT+CSQ</div>
        </div>

        <h2>üìù 8Ô∏è‚É£ R√©cup√©rer les infos du module</h2>
        <div class="step">
            <p>Obtenir l'IMEI, le CCID de la carte SIM et l'op√©rateur :</p>
            <div class="code">
AT+GSN   // IMEI du module
AT+CCID  // ID de la carte SIM
AT+COPS? // Op√©rateur utilis√©
            </div>
        </div>
    </div>


    <br>
    <br>
    <br>
    <br>

    <div class="container" id="pinggy">
        <h1 >Envoy√© qlq chose au serveur pinggy avec la config de Maxime : </h1>

        <div class="code">
            <h2 style="color: white;">Code pour envoyer un message au serveur: </h2>
            <pre>
void sendMinimalCBORMessage() {
    // 1. Pr√©parer un message simple
    const char* message = "coucou serveur";
    json j = message;
    
    // 2. Convertir en CBOR
    std::vector<uint8_t> cborData = json::to_cbor(j);
    
    // 3. Ouvrir la connexion TCP (Pinggy)
    Send_AT("AT+CAOPEN=0,0,\"TCP\",\"rntgi-185-223-151-250.a.free.pinggy.link\",41735");
    delay(3000);  // attendre que la connexion soit √©tablie
    
    // 4. Informer le module qu‚Äôon va envoyer N octets
    String cmd = "AT+CASEND=0," + String(cborData.size());
    Send_AT(cmd);
    delay(500);  // attendre le prompt '>'
    
    // 5. Envoyer les octets CBOR
    for (uint8_t byte : cborData) {
        Sim7080G.write(byte);
    }
    
    Serial.println("[ENVOY√â] CBOR minimal envoy√©");
    
    // 6. Fermer la connexion proprement
    delay(2000);
    Send_AT("AT+CACLOSE=0");
    }
            </pre>
        </div>
        <br>
        <div class="output">
            <h2> R√©sultat dans le terminal</h2>
            <pre>
Around the World
AT+GSN
860016044667504

OK
AT+CNMP=38
OK
AT+CMNB=1
OK
AT+CNACT=0,0
ERROR
AT+CGDCONT=1,"IP","iot.1nce.net"
OK
AT+CGNAPN
+CGNAPN: 0,""

OK
AT+CNCFG=0,1,iot.1nce.net
OK
AT+CEREG?
+CEREG: 0,2

OK
AT+CNACT=0,1
OKmillis de findSelect6366 voici le findSelect
=============data :
AT+CNACT=0,1
OK
indexStart: -1
indexAfterStart: 3
indexSymbolStart: 12
numberBetween_symbolStart_symbolEnd: -1
r√©sultat : 1
OK

AT+CGATT?
+CGATT: 0

OK
AT+CNACT?
+CNACT: 0,2,"0.0.0.0"
+CNACT: 1,0,"0.0.0.0"
+CNACT: 2,0,"0.0.0.0"
+CNACT: 3,0,"0.0.0.0"

OK
AT+CNACT?
+CNACT: 0,2,"0.0.0.0"
+CNACT: 1,0,"0.0.0.0"
+CNACT: 2,0,"0.0.0.0"
+CNACT: 3,0,"0.0.0.0"

OKmillis de findSelect6423 voici le findSelect
=============data :
AT+CNACT?
+CNACT: 0,2,"0.0.0.0"
+CNACT: 1,0,"0.0.0.0"
+CNACT: 2,0,"0.0.0.0"
+CNACT: 3,0,"0.0.0.0"

OK
indexStart: 14
indexAfterStart: 26
indexSymbolStart: 26
numberBetween_symbolStart_symbolEnd: 28
r√©sultat : 0

AT+GSN
860016044667504

OK
AT+CCID
89882280666170608784

OK
AT+COPS?
+COPS: 0

OK
AT+CEREG?
+CEREG: 0,2

OK
AT+CSQ
+CSQ: 99,99

OK
AT+CAOPEN=0,0,"TCP","rntgi-185-223-151-250.a.free.pinggy.link",41735
+CAOPEN: 0,1

OK

+APP PDP: 0,ACTIVE[ENVOY√â] CBOR minimal envoy√©


*PSUTTZ: 25/03/21,15:12:03","+04",0
AT+CASEND=0,15
ERROR
AT+CACLOSE=0
ERROR
AT+CAOPEN=0,0,"TCP","rntgi-185-223-151-250.a.free.pinggy.link",41735
+CAOPEN: 0,0

</pre>
<br>
<p>On peut voir que l'on a pas d'adresse IP, bien que dans les upload pr√©c√©dents, cela fonctionnait</p>
<p>Plus troublant encore, quand la m√©thode "sendMinimalCBORMessage()" est execut√©, "Send_AT("AT+CAOPEN=0,0,\"TCP\",\"rntgi-185-223-151-250.a.free.pinggy.link\",41735");"  </p>
<p>va fonctionner, on peut voir le r√©sultat ci-dessous :</p>
<img src="./images/pinggyrec.png" style="width: 60em;">
<img src="./images/coucouServer.png" style="width: 60em;">
<h5>On constate que l'on a bien "coucou serveur"</h5>
        </div>
    </div>

<br>
<br>

    <div class="container" id="machineEtat">
        <h1>üß† Machine d'√âtat AT - Documentation</h1>
        <p> Utilisation apr√®s coup de chatGPT pour expliquer mon code. </p>
        
        <div class="explanation">
          <h2>üîÅ Qu'est-ce qu'une Machine d'√âtat ?</h2>
          <p>
            Une machine d‚Äô√©tat (ou <strong>state machine</strong>) est une mani√®re de repr√©senter un processus
            qui passe par diff√©rents √©tats <em>de fa√ßon s√©quentielle et contr√¥l√©e</em>. Ici, elle g√®re l'envoi de commandes AT
            √† un module SIM7080G, en assurant les √©tapes suivantes :
          </p>
          <ul>
            <li><strong>IDLE</strong> : pr√™t √† envoyer</li>
            <li><strong>SENDING</strong> : envoie la commande</li>
            <li><strong>WAITING_RESPONSE</strong> : attend la r√©ponse</li>
            <li><strong>PARSING</strong> : analyse la r√©ponse</li>
            <li><strong>RETRY</strong> : retente si erreur ou timeout</li>
            <li><strong>ERROR</strong> : erreur d√©finitive</li>
          </ul>

          <br> 
          <p>
            Pourquoi un nom de function tel que switchPipeline ? 
        </p>
        <p> parce que ca me fait penser √† jenkins  : </p>
        <img src="./images/jenkinspipeline.png" style="width: 40em; height: 20em;">
        <p> on voit l√† un exemple de pipeline, chaque √©tape doit √™tre r√©alis√© avant de passer √† une autre</p>
            
        </div>
    
        <div class="explanation">
          <h2>üì¶ Pourquoi une <code>class</code> pour <code>MachineEtat</code> ?</h2>
          <p>
            La classe <code>MachineEtat</code> agit comme <strong>le cerveau de la machine</strong> : elle contient
            la logique de mise √† jour des √©tats pour n'importe quelle t√¢che AT (<code>ATCommandTask</code>). Cela permet
            de s√©parer la logique de traitement de l'√©tat du stockage des donn√©es.
          </p>
        </div>
    
        <div class="explanation">
          <h2>üß± Pourquoi une <code>struct</code> pour <code>ATCommandTask</code> ?</h2>
          <p>
            <code>ATCommandTask</code> est une structure qui stocke <strong>toutes les infos n√©cessaires</strong> √† une commande AT :
            <ul>
              <li>La commande √† envoyer</li>
              <li>La r√©ponse attendue</li>
              <li>Les tentatives et le timeout</li>
              <li>Le buffer de r√©ponse</li>
            </ul>
            Elle permet de g√©rer plusieurs commandes AT en parall√®le avec une seule machine d‚Äô√©tat.
          </p>
        </div>
    
        <div class="explanation">
          <h2>‚öôÔ∏è √âtapes dans <code>main.cpp</code></h2>
          <div class="step"><strong>STEP_INIT</strong> : Initialise le syst√®me</div>
          <div class="step"><strong>STEP_WAIT_SIM</strong> : Attend que la commande <code>AT+SIMCOMATI</code> r√©ussisse</div>
          <div class="step"><strong>STEP_CONFIG_CATM1</strong> : Configure le mode CATM1</div>
          <div class="step"><strong>STEP_WAIT_CNACT</strong> : Attend que <code>AT+CNACT</code> active la connexion</div>
          <div class="step"><strong>STEP_DONE</strong> : Fin du processus</div>
        </div>
    
        <div class="explanation">
          <h2>üìä √âtats de la machine</h2>
          <table>
            <thead>
              <tr>
                <th>√âtat</th>
                <th>Description</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>IDLE</td>
                <td>Pr√™t √† envoyer une commande</td>
                <td>R√©initialise le buffer, passe √† <code>SENDING</code></td>
              </tr>
              <tr>
                <td>SENDING</td>
                <td>Envoie la commande AT</td>
                <td>Attend ensuite la r√©ponse (<code>WAITING_RESPONSE</code>)</td>
              </tr>
              <tr>
                <td>WAITING_RESPONSE</td>
                <td>Analyse la r√©ponse entrante</td>
                <td>Passe √† <code>PARSING</code> si correspondance, sinon timeout ‚Üí <code>RETRY</code></td>
              </tr>
              <tr>
                <td>PARSING</td>
                <td>V√©rifie si la r√©ponse est correcte</td>
                <td>Succ√®s ‚Üí <code>IDLE</code>, sinon <code>RETRY</code></td>
              </tr>
              <tr>
                <td>RETRY</td>
                <td>Retente d‚Äôenvoyer la commande</td>
                <td>Si max atteint ‚Üí <code>ERROR</code></td>
              </tr>
              <tr>
                <td>ERROR</td>
                <td>√âtat bloqu√© en cas d‚Äô√©chec</td>
                <td>Retourne √† <code>IDLE</code> (possibilit√© d‚Äôam√©lioration ici)</td>
              </tr>
            </tbody>
          </table>
        </div>
    
        <div class="explanation">
          <h2>üß™ Exemple de t√¢che AT</h2>
          <pre class="code">
    ATCommandTask task("AT+SIMCOMATI", "860016044667504", 10, 3000);
    machine.updateATState(task);
          </pre>
          <p>
            Ici, la machine va g√©rer l‚Äôenvoi automatique de la commande et passer par tous les √©tats jusqu‚Äô√† r√©ussite ou √©chec.
          </p>
        </div>
    
      </div>
</body>
</html>