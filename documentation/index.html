<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./css/style.css">
</head>
<body>
    <p>Build automatiquement en faisant upload - restart l'upload </p>
    <h4>Ne pas hÃ©siter Ã  spam le ctrl + alt + s, ca peut fonctionner au bout d'un moment</h4>
    <h4>OVERFLOW millis() </h4>

    <h5>Appuyer deux fois sur enable et l'autre boutons en mÃªme temps. 
    <br>Ensuite relacher le bouton enable, ca va boot. <br>
    Puis appuyer une fois sur enable et on va pouvoir restart.</h5>

    <div class="container">
        <h1>l'OVERFLOW</h1> 
        <p>L'overflow (dÃ©passement) est un problÃ¨me classique en programmation bas niveau, 
        notamment en C et dans lâ€™IoT, oÃ¹ les ressources mÃ©moire sont limitÃ©es.
        <br> Cela se produit lorsqu'une valeur dÃ©passe la capacitÃ© de stockage d'un type de donnÃ©e.</p>
    </div>
        <br>
        <div class="container">
            <h2>description carte</h2>
            
            <img src="./images/carte.jpg">
            <img src="./images/esp-sim.png.jpg">
        </div>

        <div class="container">

        <br>
        <h2>Issue COM3 - PORT </h2>
        <img src="./images/issue-com3.jpg">
        <p>Quand vous avez l'erreur que vous voyez : "Serial port COM3
            
            A fatal error occurred: Could not open COM3, the port doesn't exist
            *** [upload] Error 2
            ======================"
            <br> il faut appuyer sur la prise (fluo en jaune), ensuite choisir le nouveau com (en vert : "com4").
            <br> Ensuite upload. 
        </p>
        </div>
        <br>
        <div class="container">
        <h2> NIVEAU DE BATTERIE </h2>
        <img src="./images/niveau_batterie.jpg">
        <p>La commande AT+CBC renvoie lâ€™Ã©tat de la batterie sous cette forme :
            <br>
           "
            +CBC: batterie_status, niveau_batterie, voltage_mV
            OK"

            <br><br>
            batterie_status :
            <br>0 = Non branchÃ©
            <br>1 = Chargement
            <br>2 = ChargÃ©
            <br>niveau_batterie : Pourcentage de la batterie (0 Ã  100)
            <br>voltage_mV : Tension de la batterie en millivolts (mV)</p>

        </div>

    <br>
    <br>
    <br>
    <h5>IMPORTANT : ne pas importer plusieurs fois le mÃªme fichier hpp sous peine d'avoir des bug en cascade, par exemple appeler la mÃªme variable deux fois </h5>
    <h5> Quand on a plus le coucou : on doit juste appuyer sur le bouton enable</h5>
    <br>
    <br>
    <br>
    <br>

    <div class="container">
    <h2>Modification du fichier platform.ini</h2>
    <p>build_flags =
      <br>  -I../lib
      <br>  -I../lib/gnss
      <br>  -I../lib/power
      <br>  -I../lib/timestamp
      <br>  -I../lib/serial
      <br>  -I../lib/argali
    </p>

    <br>
    <p> build_flags va servir Ã  ne pas remettre le chemin relatif de nos dossiers Ã  chaque fois </p>
    </div>
    <br>
    <div class="container">
        <h1>ğŸ” Les Pointeurs en C</h1>
        
        <p>Oui, tu peux dÃ©finir plusieurs pointeurs qui pointent vers la mÃªme variable. Cela signifie que si tu modifies la valeur via lâ€™un des pointeurs, tous les autres la verront aussi !</p>
        
        <h2>ğŸ“Œ Exemple de code :</h2>
        <pre>
#include &lt;stdio.h&gt;

int main() {
    int nombre = 42;      // DÃ©clare une variable normale
    int *ptr1 = &nombre;  // Premier pointeur
    int *ptr2 = &nombre;  // DeuxiÃ¨me pointeur

    printf("Avant modification : %d\n", nombre);
    
    *ptr1 = 99;  // Modification via ptr1

    printf("AprÃ¨s modification via ptr1 : %d\n", nombre);
    printf("Valeur via ptr2 : %d\n", *ptr2);  // ptr2 voit aussi la mise Ã  jour

    return 0;
}
        </pre>

        <div class="explanation">
            <h2>ğŸ§ Explication :</h2>
            <p>1ï¸âƒ£ <strong>CrÃ©ation de la variable :</strong> <code>int nombre = 42;</code></p>
            <p>2ï¸âƒ£ <strong>DÃ©claration de deux pointeurs :</strong> <code>ptr1</code> et <code>ptr2</code> stockent lâ€™adresse de <code>nombre</code>.</p>
            <p>3ï¸âƒ£ <strong>Modification via <code>ptr1</code> :</strong> <code>*ptr1 = 99;</code> change directement la valeur de <code>nombre</code>.</p>
            <p>4ï¸âƒ£ <strong>Affichage avec <code>ptr2</code> :</strong> Il affiche aussi <code>99</code>, car il pointe sur la mÃªme adresse.</p>
        </div>

        <h2>ğŸ“¤ Sortie du programme :</h2>
        <pre>
Avant modification : 42
AprÃ¨s modification via ptr1 : 99
Valeur via ptr2 : 99
        </pre>

        <p>âœ… Plusieurs pointeurs peuvent partager la mÃªme adresse en mÃ©moire. Toute modification via lâ€™un dâ€™eux impacte directement la variable pointÃ©e.</p>
    </div>

    <br>
    <br>
    <br>

    <div class="container">
        <h1>ğŸ“Œ Pourquoi utiliser des pointeurs en argument de fonction ?</h1>

        <p>En C, utiliser des pointeurs dans les fonctions offre plusieurs avantages, notamment :</p>

        <h2>âœ… 1ï¸âƒ£ Modifier directement une variable</h2>
        <p>Sans pointeur, la fonction copie la variable, donc elle ne la modifie pas rÃ©ellement :</p>
        <pre>
int incrementer(int x) {
    x += 1;
    return x;
}</pre>
        <p>Avec un pointeur, la fonction modifie directement la variable en mÃ©moire :</p>
        <pre>
void incrementer(int *x) {
    *x += 1;
}</pre>

        <h2>âœ… 2ï¸âƒ£ Ã‰viter de copier une `struct` (Optimisation mÃ©moire)</h2>
        <p>Sans pointeur, la `struct` est copiÃ©e :</p>
        <pre>
void afficherPoint(Point p) {
    printf("Point (%d, %d)\n", p.x, p.y);
}</pre>
        <p>Avec un pointeur, on Ã©vite la copie (plus rapide) :</p>
        <pre>
void afficherPoint(Point *p) {
    printf("Point (%d, %d)\n", p->x, p->y);
}</pre>

        <h2>âœ… 3ï¸âƒ£ Retourner plusieurs valeurs</h2>
        <p>Sans pointeur, une fonction ne peut retourner qu'une seule valeur :</p>
        <pre>
int somme(int a, int b) {
    return a + b;
}</pre>
        <p>Avec des pointeurs, on peut retourner plusieurs valeurs :</p>
        <pre>
void calculer(int a, int b, int *somme, int *difference) {
    *somme = a + b;
    *difference = a - b;
}</pre>

        <h2>âœ… 4ï¸âƒ£ Retourner un tableau</h2>
        <p>En C, une fonction ne peut pas retourner un tableau directement :</p>
        <pre>
// Impossible :
int tableau[5];
return tableau;  // ERREUR</pre>
        <p>Mais avec un pointeur, câ€™est possible :</p>
        <pre>
int* creerTableau(int taille) {
    int *tab = (int*) malloc(taille * sizeof(int));
    return tab;
}</pre>

        <div class="explanation">
            <h2>ğŸ¯ Comparaison des mÃ©thodes</h2>
            <table>
                <tr>
                    <th>Cas dâ€™usage</th>
                    <th>Sans pointeur</th>
                    <th>Avec pointeur</th>
                </tr>
                <tr>
                    <td>Modifier une variable</td>
                    <td>Copie, pas de modification directe</td>
                    <td>Modifie directement la valeur</td>
                </tr>
                <tr>
                    <td>Passer une `struct`</td>
                    <td>Copie complÃ¨te (lent)</td>
                    <td>Passe l'adresse (rapide)</td>
                </tr>
                <tr>
                    <td>Retourner plusieurs valeurs</td>
                    <td>Impossible</td>
                    <td>Possible avec plusieurs pointeurs</td>
                </tr>
                <tr>
                    <td>Retourner un tableau</td>
                    <td>Impossible</td>
                    <td>Possible avec un pointeur</td>
                </tr>
            </table>
        </div>

        <p>ğŸ’¡ En rÃ©sumÃ© :</p>
        <ul>
            <li>âœ… Si tu veux modifier une variable â†’ Utilise un pointeur</li>
            <li>âœ… Si tu veux Ã©viter de copier une `struct` â†’ Utilise un pointeur</li>
            <li>âœ… Si tu veux retourner plusieurs valeurs â†’ Utilise des pointeurs</li>
            <li>âœ… Si tu veux retourner un tableau â†’ Utilise un pointeur</li>
        </ul>

        <p><strong>Tu veux un exemple plus avancÃ© avec gestion mÃ©moire et objets dynamiques ? ğŸš€ğŸ˜Š</strong></p>
    </div>

    <br>
    <br>
    <br>

    <div class="container">
        <h1>âœ… ğŸ“ Pointeurs et Fonctions ImbriquÃ©es en C</h1>

        <h2>ğŸ“Œ Code C :</h2>
        <pre>
#include &lt;stdio.h&gt;

// Fonction secondaire qui modifie la variable
void ajouter10(int *ptr) {
    printf("[ajouter10] Adresse reÃ§ue : %p, Valeur avant : %d\n", ptr, *ptr);
    *ptr += 10;  // Ajoute 10 Ã  la valeur pointÃ©e
    printf("[ajouter10] Valeur aprÃ¨s : %d\n", *ptr);
}

// Fonction principale qui appelle une autre fonction
void function(int *ptr) {
    printf("[function] Adresse reÃ§ue : %p, Valeur actuelle : %d\n", ptr, *ptr);
    ajouter10(ptr);  // Appel Ã  une autre fonction en passant le pointeur
    printf("[function] Valeur aprÃ¨s appel de ajouter10 : %d\n", *ptr);
}

int main() {
    int variable = 5;

    printf("[main] Avant function - Adresse de variable : %p\n", &variable);
    printf("[main] Avant function - Valeur de variable : %d\n", variable);

    function(&variable);  // On passe l'adresse de la variable

    printf("[main] AprÃ¨s function - Valeur de variable : %d\n", variable);

    return 0;
}
        </pre>

        <div class="explanation">
            <h2>ğŸ” Explication :</h2>
            <p>1ï¸âƒ£ `main()` crÃ©e une variable `variable = 5`.</p>
            <p>2ï¸âƒ£ Il passe lâ€™adresse de `variable` Ã  `function(&variable)`.</p>
            <p>3ï¸âƒ£ `function()` affiche l'adresse et la valeur, puis appelle `ajouter10(ptr)` en passant toujours le pointeur.</p>
            <p>4ï¸âƒ£ `ajouter10()` ajoute `10` Ã  la valeur de `variable` via le pointeur.</p>
            <p>5ï¸âƒ£ Retour dans `function()`, qui affiche la nouvelle valeur (`15`).</p>
            <p>6ï¸âƒ£ Retour Ã  `main()`, la variable a bien Ã©tÃ© modifiÃ©e.</p>
        </div>

        <h2>ğŸ“¤ Sortie du programme :</h2>
        <div class="output">
            [main] Avant function - Adresse de variable : 0x7ffee12a1b<br>
            [main] Avant function - Valeur de variable : 5<br>
            [function] Adresse reÃ§ue : 0x7ffee12a1b, Valeur actuelle : 5<br>
            [ajouter10] Adresse reÃ§ue : 0x7ffee12a1b, Valeur avant : 5<br>
            [ajouter10] Valeur aprÃ¨s : 15<br>
            [function] Valeur aprÃ¨s appel de ajouter10 : 15<br>
            [main] AprÃ¨s function - Valeur de variable : 15<br>
        </div>  
    </div>

    <br>
    <br>
    <br>

    <div class="container">
        <h1>âœ… Passer une `struct` dans une fonction en C</h1>

        <h2>âœ… 1ï¸âƒ£ Passer une struct SANS pointeur (Copie de la struct)</h2>
        <pre>
#include &lt;stdio.h&gt;

// DÃ©finition d'une structure
typedef struct {
    char nom[50];
    int age;
} Personne;

// Fonction qui prend une struct par valeur (copie)
void afficherPersonne(Personne p) {
    printf("Nom : %s, Ã‚ge : %d\n", p.nom, p.age);
}

int main() {
    // CrÃ©ation d'une instance de struct
    Personne p1 = {"Alice", 25};

    // Passage de la structure Ã  la fonction
    afficherPersonne(p1);

    return 0;
}
        </pre>

        <h3>ğŸ“¤ Sortie :</h3>
        <div class="output">
            Nom : Alice, Ã‚ge : 25
        </div>

        <div class="explanation">
            <h2>âš ï¸ Attention :</h2>
            <ul>
                <li>âœ… Ici, la `struct` est **copiÃ©e** dans `afficherPersonne()`.</li>
                <li>âš ï¸ **Toute modification** dans `afficherPersonne()` **ne changera pas l'originale** `p1`.</li>
                <li>âš ï¸ Peu optimal pour des `struct` volumineuses, **car cela duplique les donnÃ©es**.</li>
            </ul>
        </div>

        <h2>âœ… 2ï¸âƒ£ Passer une struct AVEC pointeur (`*struct`)</h2>
        <pre>
#include &lt;stdio.h&gt;

// DÃ©finition d'une structure
typedef struct {
    char nom[50];
    int age;
} Personne;

// Fonction qui prend un pointeur sur une struct (modification directe)
void modifierAge(Personne *p) {
    p->age += 1;  // Modification directe via le pointeur
}

int main() {
    // CrÃ©ation d'une instance de struct
    Personne p1 = {"Bob", 30};

    printf("Avant : %s a %d ans\n", p1.nom, p1.age);

    // Passage par adresse
    modifierAge(&p1);

    printf("AprÃ¨s : %s a %d ans\n", p1.nom, p1.age);

    return 0;
}
        </pre>

        <h3>ğŸ“¤ Sortie :</h3>
        <div class="output">
            Avant : Bob a 30 ans<br>
            AprÃ¨s : Bob a 31 ans
        </div>

        <div class="explanation">
            <h2>âœ… Avantages de l'utilisation d'un pointeur :</h2>
            <ul>
                <li>âœ… On passe **l'adresse** de `p1` avec `&p1`.</li>
                <li>âœ… **Modification directe** de la variable `p1` dans la mÃ©moire.</li>
                <li>âœ… **Pas de copie inutile**, idÃ©al pour des `struct` volumineuses.</li>
            </ul>
        </div>
    </div>
    <br>
    <br>
    <br>
    <br>

    <div class="container">
        <h1>âœ… Utilisation de `std::map` et `std::cout` en C++</h1>

        <h2>ğŸ“Œ Exemple d'utilisation de `std::map`</h2>
        <pre>
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

int main() {
    // DÃ©claration d'une map (clÃ© = string, valeur = int)
    std::map&lt;std::string, int&gt; ages;

    // Ajout de valeurs
    ages["Alice"] = 25;
    ages["Bob"] = 30;
    ages["Charlie"] = 22;

    // Affichage avec std::cout
    for (const auto &pair : ages) {
        std::cout << pair.first << " a " << pair.second << " ans" << std::endl;
    }

    return 0;
}
        </pre>

        <h3>ğŸ“¤ Sortie :</h3>
        <div class="output">
            Alice a 25 ans<br>
            Bob a 30 ans<br>
            Charlie a 22 ans
        </div>

        <div class="explanation">
            <h2>ğŸ” Explication :</h2>
            <ul>
                <li>âœ… `std::map&lt;std::string, int&gt;` est une **map associant une clÃ© (`string`) Ã  une valeur (`int`)**.</li>
                <li>âœ… `ages["Alice"] = 25;` **ajoute une clÃ© "Alice" avec la valeur 25**.</li>
                <li>âœ… La boucle `for` parcourt tous les Ã©lÃ©ments de la map et affiche les clÃ©s/valeurs.</li>
            </ul>
        </div>

        <h2>ğŸ“Œ Explication de `std::cout`</h2>
        <pre>
#include &lt;iostream&gt;

int main() {
    std::string nom = "Alice";
    int age = 25;

    // Affichage avec std::cout
    std::cout << "Nom : " << nom << ", Ã‚ge : " << age << std::endl;

    return 0;
}
        </pre>

        <h3>ğŸ“¤ Sortie :</h3>
        <div class="output">
            Nom : Alice, Ã‚ge : 25
        </div>

        <div class="explanation">
            <h2>ğŸ”¹ Comment fonctionne `std::cout` ?</h2>
            <ul>
                <li>âœ… `std::cout` signifie **"Character Output"**, il affiche des messages.</li>
                <li>âœ… `<<` est l'**opÃ©rateur de flux** qui concatÃ¨ne les Ã©lÃ©ments.</li>
                <li>âœ… `std::endl` signifie **"End Line"**, il ajoute un retour Ã  la ligne (`\n`).</li>
            </ul>
        </div>
    </div>

    <br>
    <br>

    <div class="container">
        <h1>Connexion via 4G</h1>
        <img src="./images/connection4G.png">
        <img src="./images/terminalconnection4G.png">
        <h1>ğŸ“¡ Connexion LTE-M avec SIM7080G</h1>
        <p>Voici comment configurer le module SIM7080G pour se connecter au rÃ©seau LTE-M.</p>
        
        <h2>ğŸ” 1ï¸âƒ£ SÃ©lectionner LTE-M uniquement</h2>
        <div class="step">
            <p>On force le module Ã  utiliser LTE-M uniquement :</p>
            <div class="code">AT+CNMP=38</div>
        </div>

        <h2>ğŸš€ 2ï¸âƒ£ Activer LTE-M et dÃ©sactiver NB-IoT</h2>
        <div class="step">
            <p>NB-IoT n'est pas supportÃ© sur cette puce :</p>
            <div class="code">AT+CMNB=1</div>
        </div>

        <h2>ğŸŒ 3ï¸âƒ£ Configurer l'APN</h2>
        <div class="step">
            <p>On dÃ©finit l'APN de l'opÃ©rateur pour la connexion Internet :</p>
            <div class="code">AT+CGDCONT=1,"IP","iot.1nce.net"</div>
        </div>

        <h2>ğŸ“¶ 4ï¸âƒ£ VÃ©rifier l'enregistrement sur le rÃ©seau</h2>
        <div class="step">
            <p>On vÃ©rifie si le module est bien connectÃ© au rÃ©seau LTE-M :</p>
            <div class="code">AT+CEREG?</div>
        </div>

        <h2>ğŸŒ 5ï¸âƒ£ Activer la connexion Internet</h2>
        <div class="step">
            <p>On active la connexion Internet (PDP context) :</p>
            <div class="code">AT+CNACT=0,1</div>
        </div>

        <h2>ğŸ“¡ 6ï¸âƒ£ VÃ©rifier la connexion LTE-M</h2>
        <div class="step">
            <p>On s'assure que la connexion est bien active :</p>
            <div class="code">AT+CGATT?</div>
        </div>

        <h2>ğŸ“Š 7ï¸âƒ£ VÃ©rifier la qualitÃ© du signal</h2>
        <div class="step">
            <p>On teste la puissance du signal :</p>
            <div class="code">AT+CSQ</div>
        </div>

        <h2>ğŸ“ 8ï¸âƒ£ RÃ©cupÃ©rer les infos du module</h2>
        <div class="step">
            <p>Obtenir l'IMEI, le CCID de la carte SIM et l'opÃ©rateur :</p>
            <div class="code">
AT+GSN   // IMEI du module
AT+CCID  // ID de la carte SIM
AT+COPS? // OpÃ©rateur utilisÃ©
            </div>
        </div>
    </div>
</body>
</html>