
# ğŸŒ Projet IoT â€“ ESP32 + SIM7080G

Ce projet utilise une carte **ESP32** connectÃ©e Ã  un module **SIM7080G** pour envoyer des donnÃ©es vers un serveur distant via le rÃ©seau **4G (CAT-M1 / NB-IoT)**.

## ğŸ“¦ MatÃ©riel utilisÃ©

- âœ… ESP32 (ex : Adafruit QT Py ESP32-C3)
- âœ… Module SIM7080G (communication AT via UART)
- âœ… Carte SIM compatible CAT-M1 ou NB-IoT
- âœ… Antenne LTE
- âœ… AccÃ¨s Internet mobile (rÃ©seau 4G)

---

## ğŸ“ Structure du projet

- `src/` â€“ Code principal de l'ESP32 (PlatformIO)
- `lib/` â€“ Modules (gestion AT, machine dâ€™Ã©tat, etc.)
- `documentation/` â€“ Documentation HTML (avec index.html)

---

## ğŸ“š Documentation

La documentation du projet est disponible dans le fichier :



### â–¶ï¸ Pour lâ€™ouvrir facilement :

1. Installe lâ€™extension **Live Server** dans VS Code  
2. Clic droit sur `index.html`  
3. SÃ©lectionne **"Open with Live Server"**

ğŸ’¡ Cela ouvrira automatiquement la page dans ton navigateur pour une lecture fluide.

---

## ğŸš€ FonctionnalitÃ©s implÃ©mentÃ©es

- ğŸ“¡ Connexion rÃ©seau via SIM7080G
- ğŸ“¤ Envoi de donnÃ©es en CBOR (format binaire compact)
- ğŸ§  Machine d'Ã©tat pour gÃ©rer les Ã©changes AT de maniÃ¨re non bloquante
- ğŸŒ Envoi des donnÃ©es sur un serveur distant via TCP/Pinggy

---

## ğŸ› ï¸ DÃ©pendances

- PlatformIO avec framework `arduinoespressif32`
- BibliothÃ¨que JSON [nlohmann/json](https://github.com/nlohmann/json)
- Librairie base64 (optionnelle pour debug)

---

## âœ… Ã€ venir

- Lecture de capteurs
- Encapsulation des donnÃ©es dans des structures JSON/CBOR plus complÃ¨tes
- RÃ©ception de commandes depuis le serveur

---

## ğŸ§‘â€ğŸ’» Auteur

Ce projet a Ã©tÃ© rÃ©alisÃ© dans le cadre dâ€™un projet IoT Ã©tudiant â€“ encadrÃ© par JUNIA.

---

## ğŸ§© Structure avancÃ©e du projet

Pour garder un code propre, modulaire et Ã©volutif, jâ€™ai sÃ©parÃ© certaines responsabilitÃ©s en plusieurs dossiers spÃ©cifiques :

### ğŸ“ `context/`
Ce dossier contient tous les objets globaux et partagÃ©s du projet (par exemple : objets `MachineEtat`, `ATCommandTask`, buffers, Ã©tats, etc.).

> ğŸ”„ Il joue un peu le rÃ´le de **"contexte dâ€™exÃ©cution"** que lâ€™on pourrait retrouver dans d'autres langages ou frameworks.

Cela permet d'Ã©viter dâ€™encombrer le fichier `main.cpp` avec des dÃ©clarations trop nombreuses ou globales.

---

### ğŸ“ `setup/`
Ce dossier contient les fonctions dâ€™initialisation du projet (setup rÃ©seau, setup capteurs, setup AT, etc.).

> ğŸ›  Il permet dâ€™isoler toute la configuration du matÃ©riel et du logiciel au dÃ©marrage.

Cela rend le fichier `setup()` plus lisible et facilite l'ajout de nouveaux modules Ã  lâ€™avenir.

---

### ğŸ¯ Pourquoi cette structure ?

âœ… **SÃ©paration des responsabilitÃ©s**  
âœ… **LisibilitÃ© amÃ©liorÃ©e**  
âœ… **Facilement maintenable et extensible pour le futur**  
âœ… **Ã‰vite de "polluer" les fichiers principaux (`main.cpp`, `lib/`, etc.)**

Cette organisation est pensÃ©e pour **accompagner le projet sur le long terme**, notamment si on ajoute plus de protocoles, de capteurs, ou une logique serveur plus complexe.


